---
title: 云端图片、视频处理体系
tags: 云处理
---

# 背景

作为现代科技的重要组成部分，云端图片、视频处理的体系，为我们提供了广泛而强大的工具，极大地拓展了数字媒体处理的领域。通过将图片和视频处理移至云端，我们能够享受到更高效、灵活、可扩展的服务，能够方便、快捷、高效地服务个人用户、企业和开发者。

# 发展历程

后续如无特别声明：云端图片、视频处理体系，简称：云处理。
PS:该模块，有点废话了，不感兴趣的人直接跳过，看：[怎么搭建](#怎么搭建)

云端图片、视频处理的发展历程是一个与云计算技术和网络基础设施发展紧密相连的过程。以下是云端图片、视频处理的发展史的主要阶段：

## **起步阶段（2000年前）：**

云处理在早期主要受限于网络带宽、计算资源和存储技术的限制。由于云计算概念尚未充分发展，图片、视频计算主要依赖于本地设备进行（简称：端处理），优势：隐私性好、方便、快捷，劣势：受到硬件性能限制非常大。

## **初期云计算服务（2006年-2010年）：**

随着云计算概念的提出，云服务提供商如Amazon Web Services (AWS)、Google Cloud Platform (GCP)
、国内的阿里云等开始推出基础的云计算服务。图片、视频处理逐渐开始迁移到云端，但，规模和复杂性仍受限于当时的技术水平。

## **云端计算技术逐渐成熟（2011年-2015年）：**

在这一时期，云计算技术不断发展，云服务商提供了更多的计算、存储和网络资源。图片、视频处理也逐渐脱离本地设备，转向云端进行，提高了处理速度和效率。此时期，许多基础的图像处理和编解码服务得以涌现。

## **深度学习的兴起（2016年-至今）：**

深度学习技术的兴起对云处理产生了深远影响。深度学习算法如卷积神经网络 (CNN)
的应用使得图像和视频处理更加精确和智能。云服务商纷纷推出深度学习服务，为图像识别、人脸识别、物体检测等任务提供了强大的支持。

## **多媒体服务整合（2018年-至今）：**

云处理逐渐从简单的图像编辑、转换扩展到更复杂的多媒体服务整合。云服务商提供全面的多媒体处理服务，包括：图像识别、视频分析、实时流媒体处理等，为用户提供了更多选择。

## **边缘计算和5G技术的应用（2020年-至今）：**

随着边缘计算和5G技术的不断发展，云端图片视频处理在边缘设备上的应用逐渐增多。这使得实时性要求更高的应用，如智能监控、自动驾驶等，在边缘设备上能够更好地实现。

## **AIGC（2023年-至今）：**

刚过去的2023年，aigc爆火：文生图、图生图、文生视频等等，其底层技术架构体系，依旧还是：云端图片、视频计算体系。<br>
总体而言，云端图片、视频处理的发展历程是一个由基础计算到深度学习，再到整合多媒体服务，并涉及边缘计算和隐私保护的过程。未来，随着技术的不断进步，云端图片视频处理将在更多领域发挥作用，为用户提供更加强大和智能的服务。

# 怎么搭建

经过抽象：搭建一套云处理，包括以下模块，如下图所示：
![](/images/cps_4.png)

说明：
1、上述图展示的是：包括了多少个功能模块，并非调用顺序，各个模块的调用顺序，得根据实际功能来定，会有专门的模块来分析。
2、暂时先忽略：图里的颜色，目前并未想清楚：应该用哪些颜色来表示具体含义。

## 功能

云处理的功能，用公式来表达：媒体s = fn (媒体s，参数)，有以下特点：
1、媒体，只是狭义上的媒体，单纯地指：图片 + 视频 + 音频。
2、带上s，证明可以是：多个，也可以是0个，入参 + 出参均是如此。
3、fn：函数，特指：对入参媒体s做的动作。
4、出参：媒体s，可以是文本，例如：包括了meta的json文本、xml文本 或者：其他格式的载体。

举些例子：
例子1：视频截帧，入参是：一个视频，出参：一坨的图片，fn：截帧。
例子2：视频加logo水印：入参：1个视频 + 1张logo图片 + 一些文字，出参：一个视频，fn：拼接。
例子3：图片meta信息，入参：一张图片，出参：文本：json串，fn：计算。
例子4：文生图：入参：文本，出参：图片，fn：模型计算。
例如5：文生视频：入参：文本，出参：视频，fn：模型计算。

## 网关域

本文不探讨：为啥需要网关？因为能够看到这里的技术人员，应该都知道：搭建网关的必要性。本文将重点探讨：网关为啥要分为同步网关和异步网关？
站在用户视角来看：所见即所得，是比较好的用户体验方式。用技术术语来说，就是用户同步等待结果的显示。但是，对于大图片计算，长视频计算，往往也是非常费时的操作，极容易超时，因此，这就产生了2种产品形态：
形态1：同步等待结果模式。这个就不用展示了，太常见了。
形态2：任务列表模式。相关产品形态如下图所示：
![](/images/task_list_mode.png)
备注:
1、任务列表模式中，前端处有一个后台线程，定时轮训后端的一个接口，获取处理结果。
2、虽然：云处理的网关，按照调用方式，分为：同步网关和异步网关。但这并不是说一定要搞2个代码库，大部分情况下，只有一个代码库，多个接口，不同的部署模式。

### 通用功能

 功能    | 优先级 | 功能说明                         | 备注 |
-------|-----|------------------------------|----|
 协议转换  | T0  | 将千变万化的用户协议，转成内部的标准文件处理协议     |    | 
 参数校验  | T2  | 确保入参满足要求                     |    |
 权限认证  | T2  | 确保接入请求都合法，没有所谓的：水平越权 or 垂直越权 |    |
 计费    | T1  | 统计：调用次数、输入视频时长、使用cpu、gpu的时长等 |    |
 同步转异步 | T0  | 详见：[同步转异步](#同步转异步)           |    |

### 同步转异步

在分配计算资源触发计算之前，只有：文件url、文件大小等少量信息，不足于决策：分配合理核数的cpu or gpu。
因此，比较好的方式是：由机器自身根据当前自身负载情况去决策：应该计算多少量的视频个数，以确保整个集群资源负载更加均衡些，具体流程如下图所示：
![](/images/sync_2_async.png)
备注：
1、在物理机时代，更是如此，若无：同步转异步功能，非常容易导致：部分机器非常忙，部分机器非常闲。
2、在容器化时代，通过cgroup的方式，在本业务场景下，虽说能够缓解一部分机器负载不均的问题，但是，不能解决根本问题，极容易造成成本的浪费。
3、底层计算域，最好统一通讯范式：异步回调。
4、底层cpu or gpu可以根据自己的实际负载来拖取相关任务发起计算。
5、当业务量大时，需采用：2阶段以上的资源分配机制，其中，第一阶段：可以由网关根据请求入参，去初步：分配使用哪个配置的：cpu池子 or
gpu池子去处理，然后，第二阶段：再由底层机器，根据当前负载决策并发处理：几个计算任务。
建议：单独搞一个：资源主动调度服务来处理， 相关章节，将会在：[资源调度](/_posts/资源调度.md)详细阐述，这里面只是粗浅地介绍下。

## 状态域

对于运营 or 产品 or 技术等各方角色，都需要有一后台系统管理，能够查询到：用户在什么时间，用了什么样的设备，用了哪张图片 or
哪个视频，触发了什么动作，最终输出了什么样的结果？这个系统，应该包括以下功能：

 功能     | 优先级 | 功能说明                                                            | 备注                                                                   |
--------|-----|-----------------------------------------------------------------|----------------------------------------------------------------------|
 meta信息 | T0  | 1、记录图片：宽、高、文件大小、色域等meta信息 <br> 2、记录视频的宽、高、文件大小、视频时长、音频时长等meta信息 | 刚需，业务侧经常使用，对获取meta信息的接口性能也有要求。建议：缓存到redis or mysql or local cache等地方 |
 索引信息   | T1  | 记录图片、视频的处理前后的索引信息。包括：输入媒体是哪些？经过了哪些处理？输出媒体有哪些？方便运营侧分析运营数据        |                                                                      |
 优化计算   | T1  | 详见：[优化计算](#优化计算)                                                |                                                                      | 
 碎片     | T1  | 详见：[碎片](#碎片)                                                    |                                                                      |
 cdn成本  | T0  | 详见：[cdn成本](#cdn成本)                                              |                                                                      |
 播放体验   | T0  | 详见：[播放体验](#播放体验)                                                |                                                                      |

### 优化计算

云处理，用公式来表达：媒体s = fn (媒体s，参数)，它有一特点：
只要媒体s+参数+fn是固定的，无论何时、何地，再次发起计算，对于用户而言，它的结果都应该是一样的。假设不一样，则对于用户而言，属于bug。因此，可以利用这一点，缓存一段时间的计算结果
相关流程如下：
![](/images/optimize_cal_1.png)
说明：
1、好处：一方面：能够加速处理速度，提升用户体验，另外一方面：能够节约cpu or gpu计算成本。
2、将结果缓存起来，可以选择：关系型数据库：mysql 或者：非关系型数据库：redis，根据实际情况来定。

### 碎片

所谓碎片，顾名思义：业务系统因某种原因，未能及时追踪到的文件。日积月累后，该部分成本相关可观。如下图所示：
![](/images/file_piece.png)
碎片产生的原因，一般有以下几种：
1、业务操作不当，导致引用的内容被删除后，相对应的文件，没有正常删除。
2、小文件存储系统都有分片上传功能，当分片上传完成后，一般只有一个结果文件存在。因此，中间过程文件需要及时清理掉。
3、切片加速，所产生的中间结果文件。
4、加水印过程中，有可能会产生水印图片这样的中间文件，

如何检测是否有碎片文件产生？
1、业务侧通过记录：业务期许的媒体文件信息大小 跟小文件存储系统做一个对比，能够大致知道：是否有碎片的产生。
2、梳理业务的全过程。

如何处理？

若检测到有碎片产生，则跟小文件存储的人员，商讨技术优化方案，例如：桶拆分，并配置生命周期规则 or 立即删除碎片 or 延时删除碎片等等。

### cdn成本

### 播放体验

## 编排域

详见：[任务编排](/_posts/任务编排.md)

## 仿真域

## 画质管理

如何才能决策：一个算法 or 模型具备上线的资格呢？或者说：如何评价一个算法 or 模型计算后的图片、视频的效果呢？参考流程如下：
![](/images/media_quality_mng.png)

备注：
1、画质评测，业界标准分为：主观评测 + 客观评测，但是，据了解，客观评测目前更多的还是为：以节约人力为目标，为主观评测服务的，最终决定权：还在人身上。
2、多策略跑图、跑视频，最终让人去决策：某一个版本是否可以上线，其实：也挺费算力资源 + 人力资源。

## 计算域

### 算法、模型工程化

详见：[算法、模型工程化](/_posts/算法、模型工程化.md)

### 资源调度

详见：[资源调度](/_posts/资源调度.md)

### 报文设计

1、请求报文

```json
{
  "create_time": 111112232,
  "msg_id": "19dc3271b5054216a939eb8f029e748c",
  "notify_url": "",
  "priority": 1,
  "params": {
    "": "",
    "": ""
  },
  "input_files": [
    {
      "url": "",
      "type": "",
      "cloud": "",
      "bucket": "",
      "key": ""
    }
  ],
  "output_files": [
    {
      "cloud": "",
      "bucket": "",
      "key": ""
    }
  ],
  "cmd": "",
  "extra": {
    "pre_download": true
  }
}
```

2、响应报文

```json
{
  "error_code": "",
  "error_msg": "",
  "msg_id": "",
  "success": true
}
```

3、回调报文

```json
{
  "msg_id": "",
  "code": "",
  "message": "",
  "success": true,
  "output_files": [
    {
      "cmd": "",
      "code": "",
      "message": "",
      "bucket": "",
      "key": "",
      "extra": {
        "file_size": 1111,
        "mime": "jpg or "
      }
    }
  ]
}
```

## 存储域






